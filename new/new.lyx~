#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\setcounter{secnumdepth}{3}

\usepackage{titlesec}
\titleformat{\part}
  {\normalfont\sffamily\huge}
  {\partname\ \thepart}{1em}{}
\titleformat{\chapter}[display]
  {\normalfont\sffamily\huge}
  {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
  {\normalfont\sffamily\Large}
  {\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\sffamily\large}
  {\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\sffamily\normalsize}
  {\thesubsubsection}{1em}{}

\usepackage{newtxtext}
\usepackage{titletoc}

\contentsmargin[1cm]{0cm}

\titlecontents{part}[0em]{\vskip12pt\bfseries\sffamily}
{\thecontentslabel\enspace}
{\hspace{1.05em}}
{ \hfill\contentspage}[\vskip 6pt]

\titlecontents{chapter}[0em]{\vskip12pt\bfseries\sffamily}
{\thecontentslabel\enspace}
{\hspace{1.05em}}
{ \hfill\contentspage}[\vskip 6pt]

\titlecontents{section}[1em]{\sffamily}
{\thecontentslabel\enspace}
{}
{\titlerule*[1pc]{.}\quad\contentspage}[\vskip 4pt]

\titlecontents{subsection}[2.7em]{\sffamily}
{\thecontentslabel\enspace}
{}
{\titlerule*[1pc]{.}\quad\contentspage}[\vskip 3pt]

\usepackage{listings}
\usepackage{color}
\definecolor{ltgry}{rgb}{0.95,0.95,0.95}
\definecolor{purplekeywords}{rgb}{0.75,0,0.75}
\definecolor{greycomments}{rgb}{0.5,0.5,0.5}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\lstset{backgroundcolor=\color{ltgry}}

\lstset{columns=fixed, basicstyle=\ttfamily, basewidth=0.55em}

\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "Baskerville"
\font_sans "default" "Helvetica"
\font_typewriter "default" "Andale Mono"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 80 80
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Java,showspaces=false,showtabs=false,breaklines=true,showstringspaces=false,breakatwhitespace=true,escapeinside={(*@}{@*)},commentstyle={\color{greycomments}},keywordstyle={\color{purplekeywords}\bfseries},stringstyle={\color{redstrings}},basicstyle={\ttfamily},morekeywords={ var, fn, print,in }"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\family sans
\emph on
\begin_inset Graphics
	filename Figures/morphologo.pdf
	width 3.5in

\end_inset


\begin_inset Newline newline
\end_inset

The Morpho book
\begin_inset Newline newline
\end_inset

Version 0.6.1
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 is a dynamic language oriented toward scientific computing that was designed
 with the following goals:
\end_layout

\begin_layout Itemize

\series bold
Familiar.

\series default
 
\emph on
Morpho
\emph default
 uses syntax similar to other C-family languages.
 
\end_layout

\begin_layout Itemize

\series bold
Simple.

\series default
 The syntax has been kept simple, so there are only a few things to learn;
 nonetheless, the features provided are very expressive, enabling the programmer
 to express intent cleanly.
\end_layout

\begin_layout Itemize

\series bold
Fast.

\series default
 
\emph on
Morpho
\emph default
 programs run as efficiently as other well-implemented dynamic languages
 like wren, lua or python.
 
\emph on
Morpho
\emph default
 leverages numerical libraries like BLAS, LAPACK, etc.
 to provide good performance.
 
\end_layout

\begin_layout Itemize

\series bold
Class-based.

\series default
 
\emph on
Morpho
\emph default
 is highly object-oriented, which simplifies coding and enables reusability.
 
\end_layout

\begin_layout Itemize

\series bold
Extendable.

\series default
 Functionality is easy to extend add via modules, which can be written in
 
\emph on
Morpho
\emph default
 or C and other compiled languages.
\end_layout

\begin_layout Standard
This book is intended as a brief introduction to 
\emph on
Morpho
\emph default
, illustrating its features and providing some advice on how to use them
 best.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Inspirations
\end_layout

\begin_layout Plain Layout

\emph on
Morpho
\emph default
 is inspired by a number of other languages, to which we briefly compare
 and contrast 
\emph on
Morpho
\emph default
:
\end_layout

\begin_layout Itemize
Like 
\emph on
Lua
\emph default
, 
\emph on
Morpho
\emph default
 is primarily a scripting language with a simple syntax that is embeddable
 in other programs.
 The range of provided types in 
\emph on
Morpho
\emph default
 is somewhat richer than Lua, and oriented toward object oriented programming.
 In Lua the primary construct is the Table, which can be used to emulate
 object oriented programming, but 
\emph on
Morpho
\emph default
 provides explicit OOP constructs.
 
\end_layout

\begin_layout Itemize
Like 
\emph on
Dylan
\emph default
, 
\emph on
Morpho
\emph default
 is object oriented and provides efficient multiple dispatch using similar
 techniques.
 
\end_layout

\begin_layout Itemize
Like 
\emph on
Julia
\emph default
, 
\emph on
Morpho
\emph default
 provides efficient multiple dispatch, but centralizes object oriented programmi
ng.
\end_layout

\begin_layout Itemize
Like 
\emph on
C
\emph default
, 
\emph on
C++
\emph default
, 
\emph on
Java
\emph default
 and even 
\emph on
JavaScript
\emph default
, 
\emph on
Morpho
\emph default
 uses the C family code block style and similar notation for function definition
s (and class definitions for object-oriented C family languages).
 In contrast to most C family languages, semicolons are almost entirely
 optional.
 
\end_layout

\begin_layout Itemize
Like all modern dynamic languages, 
\emph on
Morpho
\emph default
 is inspired by 
\emph on
Smalltalk 
\emph default
although more in its commitment to programmer's agency, and programming
 as a fun and exploratory activity than through the syntax.
\end_layout

\begin_layout Itemize
Many languages, including 
\emph on
Lua
\emph default
, 
\emph on
Java
\emph default
 (historically), 
\emph on
Smalltalk
\emph default
, 
\emph on
Python, Wren
\emph default
, 
\emph on
Lox
\emph default
, 
\emph on
Morpho
\emph default
 uses a bytecode compiler and virtual machine to provide good performance.
 Unlike most of these languages, the VM is a register machine rather than
 a stack machine.
 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Variables and types
\begin_inset CommandInset label
LatexCommand label
name "chap:Variables-and-types"

\end_inset


\end_layout

\begin_layout Standard
Like many languages, 
\emph on
Morpho
\emph default
 allows the programmer to define 
\emph on
variables
\emph default
 to contain pieces of information of 
\emph on
values
\emph default
.
 A variable is created using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

var
\end_layout

\end_inset

 keyword, which is followed by the variable name
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Variable names must begin with an alphabetical character or the underscore
 character 
\family typewriter
_
\family default
, and may consist of any combination of alphanumeric characters or underscores
 thereafter.
 Variable names are case sensitive, so 
\end_layout

\begin_layout Standard
\noindent
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a
\end_layout

\begin_layout Plain Layout

var A
\end_layout

\end_inset

each refer to distinct variables.
\end_layout

\begin_layout Standard
\noindent
After creating a variable, you may immediately store information in it by
 providing an 
\emph on
initializer, 
\emph default
which can be any value
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var i = 1
\end_layout

\begin_layout Plain Layout

var str = 
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 is a dynamically typed language: Every value has a definite type, and Morpho
 is always able to tell what type it is, but variables may generally contain
 values of any type and functions or methods can accept arguments of any
 type.
 
\end_layout

\begin_layout Standard
There are a number of basic types in Morpho:
\end_layout

\begin_layout Description
nil is a special value that represents the 
\emph on
absence
\emph default
 of information and is different from any other value.
 Unless an initializer is provided, Morpho variables initially contain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

 after declaration.
 
\end_layout

\begin_layout Description
Bool values contain either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Description
Int values contain 32 bit signed integer numbers.
 An integer constant is written intuitively, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

50
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1000
\end_layout

\end_inset

 and may include a negative sign 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-100
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
Float values contain double precision floating point numbers.
 You can write numeric constants either using a decimal 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1.5
\end_layout

\end_inset

 or in scientific notation, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1e10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1.6e-19
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

6.625e26
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In addition to these basic types, Morpho provides a rich collection of 
\series bold
objects
\series default
.
 Discuss immutability i.e.
 cannot be changed after creation, or not
\end_layout

\begin_layout Section
Strings
\end_layout

\begin_layout Standard
Strings are sequences of unicode UTF8 encoded characters.
 You specify a literal string using double quotes
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var h = 
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

Literal strings can contain a number of special characters, which are introduced
 by a backslash character as in the table below
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Form feed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Newline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Carriage return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tab
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unicode character (followed by 4 hex digits)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unicode character (followed by 8 hex digits)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unicode character (followed by 2 hex digits)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Backslash
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quote
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
To create a string incorporating the morpho butterfly emoji, for example,
 you would use
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset


\backslash
U0001F98B morpho
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

Hex digits are not case sensitive.
 
\end_layout

\begin_layout Standard
You may also insert the results of arbitrary expressions (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Expressions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a 
\emph on
Morpho
\emph default
 string using
\emph on
 interpolation 
\emph default
as in the following example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 
\begin_inset Quotes eld
\end_inset

Hello ${name}! Happy ${age} birthday
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

The values of the variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

age
\end_layout

\end_inset

 are converted to strings if necessary and joined with the surrounding string.
 
\end_layout

\begin_layout Standard
To convert something to a string, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 constructor
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print String(1.5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that Strings in Morpho are 
\emph on
immutable
\emph default
.
 Their contents cannot be changed, and operations on strings always return
 a new String:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 
\begin_inset Quotes eld
\end_inset

ABC
\begin_inset Quotes erd
\end_inset

 + 
\begin_inset Quotes eld
\end_inset

DEF
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Lists
\end_layout

\begin_layout Standard
Lists are ordered sequences of values.
 They can be created either through the syntax
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = [1,2,3]
\end_layout

\end_inset

or using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 constructor
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = List(1,2,3)
\end_layout

\end_inset

which converts its arguments into a List.
 
\end_layout

\begin_layout Standard
Elements of a list can be accessed using the index notation
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print a[0] // Prints the first element
\end_layout

\end_inset

Note that, like all Morpho collection objects, the index 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 represents the first element.
 You can change the value of any element in the List using analogous notation
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a[0] = 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can access the last element using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print a[-1] // Prints the last element
\end_layout

\end_inset

and, more generally, negative numbers can be used to count from the end
 of the List.
 
\end_layout

\begin_layout Subsection
Stacks
\end_layout

\begin_layout Standard
One application of a List is to implement a 
\emph on
stack
\emph default
, which is a data structure to which values can be added to or removed from,
 following a Last In, First Out (LIFO) protocol.
 
\end_layout

\begin_layout Standard
We create the stack using an empty List
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var stack = []
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
and can then implement key stack operations as follows:
\end_layout

\begin_layout Itemize

\series bold
Push
\series default
 elements onto the stack:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

stack.append(1,2,3)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Pop
\series default
 the last element off the stack:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print stack.pop()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Peek
\series default
 at the last element of the stack without removing it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print stack[-1]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Check if the stack 
\series bold
is empty
\series default
:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (stack.count()==0) {
\end_layout

\begin_layout Plain Layout

	// Do something
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can use these basic operations to implement more complex operations,
 such as duplicating the last element of the stack
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a=stack.pop() 
\end_layout

\begin_layout Plain Layout

stack.append(a,a)
\end_layout

\end_inset

or swapping the top two elements
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a=stack.pop() 
\end_layout

\begin_layout Plain Layout

b=stack.pop() 
\end_layout

\begin_layout Plain Layout

stack.append(a,b)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Arrays
\end_layout

\begin_layout Standard
Arrays are multidimensional stores, and can be created as part of a variable
 declaration.
 Both of these examples create a 
\begin_inset Formula $2\times2$
\end_inset

 array:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a[2,2]
\end_layout

\end_inset

or by a constructor
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = Array(2,2)
\end_layout

\end_inset

Use index notation to set and get individual elements
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a[0,0]=1
\end_layout

\begin_layout Plain Layout

print a[0,0]
\end_layout

\end_inset

Each array element can contain any content that a regular variable can,
 so you may store Strings, Lists and even other Arrays in an Array:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a[0,0]=
\begin_inset Quotes erd
\end_inset

Hello
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

a[1,0]=[1,2,3]
\end_layout

\end_inset

All Array elements are initialized to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

 by default.
\end_layout

\begin_layout Section
Dictionaries
\end_layout

\begin_layout Standard
Dictionaries, also called 
\emph on
hashtables
\emph default
, 
\emph on
hashmaps
\emph default
 or 
\emph on
associative arrays
\emph default
, are data structures that map a set of keys to a set of values.
 This simple example maps a few state codes to their capitals:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var cap = { 
\begin_inset Quotes eld
\end_inset

MA
\begin_inset Quotes erd
\end_inset

 : 
\begin_inset Quotes eld
\end_inset

Boston
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

NY
\begin_inset Quotes erd
\end_inset

 : 
\begin_inset Quotes eld
\end_inset

Albany
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

VT
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Quotes eld
\end_inset

Montpellier
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\end_inset

You could also use the Dictionary constructor
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var cap = Dictionary(
\begin_inset Quotes eld
\end_inset

MA
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Boston
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

NY
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Albany
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

VT
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Montpellier
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

where the arguments are, alternatingly, keys and values.
\end_layout

\begin_layout Standard
Access the contents of a Dictionary using index notation
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print cap[
\begin_inset Quotes eld
\end_inset

MA
\begin_inset Quotes erd
\end_inset

]
\end_layout

\end_inset

which also allows you to add additional key-value pairs 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cap[
\begin_inset Quotes eld
\end_inset

ME
\begin_inset Quotes erd
\end_inset

]=
\begin_inset Quotes erd
\end_inset

Augusta
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any value can be used as a key in a Dictionary, but there is a subtlety:
 the behavior depends on whether the object is 
\emph on
immutable
\emph default
.
 Basic types are immutable, and hence integers work as expected
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = { 0: 
\begin_inset Quotes eld
\end_inset

Zero
\begin_inset Quotes erd
\end_inset

, 1: 
\begin_inset Quotes eld
\end_inset

One
\begin_inset Quotes erd
\end_inset

, 2: 
\begin_inset Quotes eld
\end_inset

Two
\begin_inset Quotes erd
\end_inset

}
\end_layout

\begin_layout Plain Layout

print a[0]
\end_layout

\end_inset

Lists, however, are 
\end_layout

\begin_layout Section
Ranges
\begin_inset CommandInset label
LatexCommand label
name "sec:Ranges"

\end_inset


\end_layout

\begin_layout Standard
Ranges describe a collection of values, denoted using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

..
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset

.
 The Range
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1..10
\end_layout

\end_inset

describes the collection of integers from 1 to 10 inclusive; the Range
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1...10
\end_layout

\end_inset

(note the triple dots) represents the integers from 1 to 9; the upper bound
 is 
\emph on
excluded
\emph default
.
 You can represent a range with an increment other than 1 like so
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1..9:2
\end_layout

\end_inset

which comprises the odd numbers from 1 to 9.
 Ranges work with floating point numbers, e.g.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0..1:0.1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ranges are frequently used to define the bounds of loops as will be described
 in Section X.
 
\end_layout

\begin_layout Section
Complex numbers
\end_layout

\begin_layout Standard
Morpho supports complex numbers, which can be created using the keyword
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

im
\end_layout

\end_inset

 to denote the imaginary part of a complex number 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var z = 1 + 1im
\end_layout

\end_inset

You can use any number format for either the real or imaginary parts
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 0.1im
\end_layout

\begin_layout Plain Layout

print 1e-3im
\end_layout

\end_inset

Complex numbers work with arithmetic operators just like regular numbers
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print z + 1/z
\end_layout

\end_inset

Get the real and imaginary parts of a complex number using the convenience
 functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

real
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

imag
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print real(z)
\end_layout

\begin_layout Plain Layout

print imag(z) 
\end_layout

\end_inset

or by calling the corresponding methods
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print z.real()
\end_layout

\begin_layout Plain Layout

print z.imag() 
\end_layout

\end_inset

Find the complex conjugate
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print z.conj()
\end_layout

\end_inset

and obtain the magnitude and phase
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print z.abs() // Or use the regular abs() function
\end_layout

\begin_layout Plain Layout

print z.angle() 
\end_layout

\end_inset

Note that the value 
\begin_inset Formula $\phi$
\end_inset

 returned by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

angle
\end_layout

\end_inset

 method always lies on the interval 
\begin_inset Formula $-\pi<\phi\le\pi$
\end_inset

; in some applications you will need to track the correct Riemann surface
 separately and add multiples of 
\begin_inset Formula $2\pi$
\end_inset

 as appropriate.
 
\end_layout

\begin_layout Section
Tuples
\end_layout

\begin_layout Standard
Tuples, like Lists, represent an ordered sequence of values but are immutable.
 They are created either using the syntax
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var t = (1,2,3)
\end_layout

\end_inset

or using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple
\end_layout

\end_inset

 constructor
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var t = Tuple(1,2,3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elements can be accessed using index notation
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print t[1] // Prints the second element
\end_layout

\end_inset

but an attempt to change them throws an error
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

t[0] = 5 // Throws 'ObjImmutable'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because Tuples are immutable, they can be used as keys in a Dictionary:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var dict = { (0,0): true }
\end_layout

\begin_layout Plain Layout

print dict[(0,0)] // expect: true 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Comments
\end_layout

\begin_layout Standard
Documentation of code is one of the most important tasks of the programmer.
 Code is very hard to reuse, and often hard to understand, without documentation.
 We urge the programmer to include at least two kinds of comment:
\end_layout

\begin_layout Itemize

\series bold
Inline comments
\series default
 are annotations intended to convey the intent of the programmer for what
 the code should do.
 They should be compact, clearly written and judiciously inserted.
 Include such comments wherever a section of code requires the reader to
 guess, or think deeply about a nontrivial sequence of statements, or convey
 assumptions that might not be obvious from the code.
 
\end_layout

\begin_layout Itemize

\series bold
Block comments
\series default
 are longer pieces of documentation.
 It's useful to include a block comment at the start of a program to describe
 the program, when it was written, who implemented it and how it may be
 used.
 
\end_layout

\begin_layout Standard
Morpho supports two syntactic constructs to support comments.
 The first is introduced by the marker 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

//
\end_layout

\end_inset

.
 After that, any text 
\emph on
to the end of the current line
\emph default
 is ignored by the 
\emph on
Morpho
\emph default
 compiler.
 This style is useful for annotating a statement
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var acceleration // in units of m/s^2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second style of comment is introduced by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/*
\end_layout

\end_inset

 and closed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*/
\end_layout

\end_inset

.
 Anything between, including line breaks, is ignored by the compiler.
 Such comments may therefore span multiple lines.
 The following comment documents a new class and its usage
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* A new data structure.
 
\end_layout

\begin_layout Plain Layout

   Brief description
\end_layout

\begin_layout Plain Layout

   Usage: ...
 */
\end_layout

\begin_layout Plain Layout

class DataStructure { }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike the C language, from which the notation is derived, such comments
 can be nested within one another
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* A comment /* A nested comment */ */
\end_layout

\end_inset

which facilitates the common exploratory programming practice of 
\begin_inset Quotes eld
\end_inset

commenting out
\begin_inset Quotes erd
\end_inset

 a section of code.
 
\end_layout

\begin_layout Standard
While 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

//
\end_layout

\end_inset

 is most obviously used for inline comments and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/* ...
 */
\end_layout

\end_inset

 is oriented to block comments, either style can be used for either purpose
 depending on the programmer's sense of aesthetics.
 
\end_layout

\begin_layout Chapter
Expressions
\begin_inset CommandInset label
LatexCommand label
name "chap:Expressions"

\end_inset


\end_layout

\begin_layout Standard
An expression is any construct that produces a value.
 Expressions include any combination of literal values, function or method
 calls, assignment expressions, object constructors, as well as arithmetical,
 relational and logical operations.
 
\end_layout

\begin_layout Section
Arithmetic operators
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 provides the standard binary arithmetic operators
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subtraction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Division
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

^
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exponentiation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
Hence, 
\emph on
Morpho
\emph default
 can be used, among other things, as an (overengineered) pocket calculator
 like so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 2^8-1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Comparison operators
\end_layout

\begin_layout Standard
Comparisons between expressions can be achieved using relational operators,
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Less than
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Greater than
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equal to
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Not equal to
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Less than or equal to
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Greater than or equal to
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
all of which return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 Not all expressions can be compared; Complex numbers for example, can be
 tested for equality but not compared so 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 1im < 2 // Invalid
\end_layout

\end_inset

throws a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

InvldOp
\end_layout

\end_inset

 error.
 Equality tests are more complicated than they appear.
 Comparisons of objects are only equal if they refer exactly to the same
 object, so
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print [1,2,3] == [1,2,3]
\end_layout

\end_inset

prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 because two 
\emph on
different
\emph default
 Lists are created and compared, even though their contents are identical.
 A few object types support 
\begin_inset Quotes eld
\end_inset

deep
\begin_inset Quotes erd
\end_inset

 equality comparison, such as Strings and Tuples.
 Hence
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print (1,2,3) == (1,2,3)
\end_layout

\begin_layout Plain Layout

print 
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset

 == 
\begin_inset Quotes eld
\end_inset

Hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

both print 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Logical operators
\begin_inset CommandInset label
LatexCommand label
name "sec:Logical-operators"

\end_inset


\end_layout

\begin_layout Standard
Finally, 
\emph on
Morpho
\emph default
 provides the logical operators
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NOT
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
which implement the Boolean algebra.
 All of these operators consider the two values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

 to be false; 
\emph on
any other value
\emph default
 is considered to be true.
 This is very different from C and some other languages, where the integer
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, and sometime even other values, are also considered to be false.
 
\series bold
In 
\emph on
Morpho
\emph default
, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 (like any other number) is considered to be true.
 
\end_layout

\begin_layout Standard
Like C, however, the logical operators do not always cause evaluate both
 operands to be evaluated.
 If the left operand of the AND operator is 
\emph on
false
\emph default
, for example, the right hand operand is not evaluated because the expression
 is manifestly false.
 You can see this explicitly in the following example
\end_layout

\begin_layout Standard
\noindent
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn f() { 
\end_layout

\begin_layout Plain Layout

  print "f was evaluated!"
\end_layout

\begin_layout Plain Layout

  return true 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print true && f() // f is evaluated
\end_layout

\begin_layout Plain Layout

print false && f() // f is not evaluated
\end_layout

\end_inset

Conversely, if the left operand of the OR operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset

 is 
\emph on
true
\emph default
, the right hand operand isn't evaluated because it's clear the composite
 expression must be true.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print true || f() //  f is not evaluated
\end_layout

\begin_layout Plain Layout

print false || f() // f is evaluated
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Since the NOT operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset

 has only one operand, it is always evaluated.
 
\end_layout

\begin_layout Section
Assignment
\end_layout

\begin_layout Standard
The contents of variables can be changed using assignment expressions.
 The operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

 is used to indicate assignment: the operator on the left hand is called
 the assignment 
\emph on
target
\emph default
 and is the variable or component to be modified; the operand on the right
 hand side is the value to be assigned.
 
\end_layout

\begin_layout Standard
An assignment statement can be as simple as assigning a value 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo = 1
\end_layout

\end_inset

or could involve changing the contents of a collection using index notation
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo[0] = 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A common use of assignment is to capture the return value of a function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo = sin(Pi/4)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Morpho also provides a number of shorthand assignment operators that retrieve
 and modify the contents of an assignment target and then store the result
 back in the same target: 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+=
\end_layout

\end_inset

 Increments the target by a given value, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foo += 1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-=
\end_layout

\end_inset

 Decrements the target by a given value, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foo -= 1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*=
\end_layout

\end_inset

 Multiplies the target by a given value, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foo *= 2
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/=
\end_layout

\end_inset

 Divides the target by a given value, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foo /= 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These shorthand operators are provided purely for the convenience of the
 programmer and each is entirely equivalent to a regular longhand assignment,
 e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo += 1
\end_layout

\end_inset

could equally be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo = foo + 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because assignment operators in 
\emph on
Morpho
\emph default
 are expressions, they evaluate to a value which is always the value assigned.
 Hence
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = 1
\end_layout

\begin_layout Plain Layout

print a+=1
\end_layout

\end_inset

prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

 which is the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a+1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Other expressions
\end_layout

\begin_layout Standard
There are a few other types of expression and associated operators that
 are presented elsewhere in the book:
\end_layout

\begin_layout Itemize
The 
\series bold
Range constructors
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

..
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset

 are discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Ranges"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Itemize

\series bold
Function calls
\series default
 are introduced in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Itemize

\series bold
Method calls
\series default
 are denoted by a single dot 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 and are explained in Section XXX.
 
\end_layout

\begin_layout Section
Precedence
\end_layout

\begin_layout Standard
Compound expressions like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + 2 * 3
\end_layout

\end_inset

 may appear ambiguous at first sight because it is not obviously clear which
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 + 2) * 3 = 9
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + (2 * 3) = 7
\end_layout

\end_inset

 is meant.
 Running this example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print 1 + 2 * 3
\end_layout

\end_inset

prints 7 rather than 9 because the multiplication operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

 binds to its operands with higher 
\emph on
precedence
\emph default
 than the addition operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

.
 The order of precedence in 
\emph on
Morpho
\emph default
 is as follows
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operators
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Highest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

^
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Power
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unary minus, NOT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

,
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplication and division
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

,
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addition and subtraction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

..
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range constructor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparison
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equality tests
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lowest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assignment
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
The programmer is always free to use parentheses to control the order of
 evaluation, so
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print (1 + 2) * 3
\end_layout

\end_inset

indeed prints 9.
 It is recommended to do so even if an expression is formally correct, but
 challenging for the reader to parse.
 
\end_layout

\begin_layout Chapter
Statements
\end_layout

\begin_layout Standard
Statements in 
\emph on
Morpho
\emph default
 are the basic unit of a program: they are executed one after another as
 the program is run.
 Like other C-family languages, statements are organized into
\emph on
 code blocks
\emph default
 using curly brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  var foo = 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  print foo
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Any variables created in a code block, referred to as 
\emph on
local variables
\emph default
, cease to exist once the code block is over.
 Hence this example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  var foo
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print foo // Throws an error
\end_layout

\end_inset

throws a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SymblUndf
\end_layout

\end_inset

 error.
\end_layout

\begin_layout Standard
Code blocks are themselves statements and hence can be nested arbitrarily
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  var foo = 1
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    var boo = 2
\end_layout

\begin_layout Plain Layout

    print foo + boo
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Variables defined in an outer block are visible to code in an inner block,
 so both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foo
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

boo
\end_layout

\end_inset

 are visible to the print statement, but the converse is not true.
 
\end_layout

\begin_layout Standard
As can be seen in the above example, it is common stylistic practice to
 
\emph on
indent
\emph default
 statement within code blocks using tabs or spaces.
 In 
\emph on
Morpho
\emph default
, and most other languages with the important exception of Python, indentation
 is purely aesthetic and done to improve readability; it has no special
 syntactic meaning.
\end_layout

\begin_layout Section
Declarations
\end_layout

\begin_layout Standard
An important category of statements are declarations, which define varius
 kinds of construct.
 Variable declarations were already introduced in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Variables-and-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Function declarations will be described in Chapter
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Class declarations in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Classes-and-Objects"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Expression statements
\end_layout

\begin_layout Standard
Any expression on its own is also a valid statement.
 Hence, assignment, function and method calls, etc., which are are all expression
s, are also statements
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a=5
\end_layout

\begin_layout Plain Layout

foo(
\begin_inset Quotes eld
\end_inset

boo
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

stack.pop()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Print statements
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 provides a simple way of producing output through the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print
\end_layout

\end_inset

 keyword.
 The expression after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print
\end_layout

\end_inset

 is output, most commonly to the Terminal if the terminal app is being used
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print log(10)
\end_layout

\end_inset

Some objects are able to display themselves in a user-friendly manner (sometimes
 called 
\emph on

\begin_inset Quotes eld
\end_inset

pretty printing
\begin_inset Quotes erd
\end_inset


\emph default
).
 Printing a List for example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print List(1,2,3)
\end_layout

\end_inset

displays something a List displayed in the 
\emph on
Morpho
\emph default
 syntax: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[ 1, 2, 3 ]
\end_layout

\end_inset

.
 Other objects don't provide this
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print Object()
\end_layout

\end_inset

simply displays a placeholder 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<Object>
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Print statements are provided primarily for convenience and 
\emph on
always
\emph default
 follow the output with a newline.
 For more control over printing, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

System
\end_layout

\end_inset

 class provides additional functionality as described in Chapter XXX.
 
\end_layout

\begin_layout Section
Control structures
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 provides a typical variety of 
\emph on
control structures
\emph default
, which control the order in which code is executed.
 Control blocks can conditionally execute code ( 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if ...
 else
\end_layout

\end_inset

 ), repeatedly execute code (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

do ...
 while
\end_layout

\end_inset

), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 out of a loop or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 to the next iteration.
 Morpho also provides a mechanism (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try ...
 catch
\end_layout

\end_inset

) to handle errors that are forseen by the programmer.
 
\end_layout

\begin_layout Subsection
If...else
\end_layout

\begin_layout Standard
An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement evaluates the condition expression, and if it is true, executes
 the provided statement 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (a<0) a*=a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, as discussed above in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Logical-operators"
plural "false"
caps "false"
noprefix "false"

\end_inset

, wherever a condition test is performed in 
\emph on
Morpho
\emph default
, all values (including the are considered to be equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 
\emph on
other than
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The statement to be executed is often a code block
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (a.norm() < epsilon) {
\end_layout

\begin_layout Plain Layout

  print 
\begin_inset Quotes eld
\end_inset

Converged
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

You can provide a second statement using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 keyword that is executed is the condition test was false
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (q>0) {
\end_layout

\begin_layout Plain Layout

  print 
\begin_inset Quotes eld
\end_inset

Positive definite
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  print 
\begin_inset Quotes eld
\end_inset

Not positive
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It's possible to chain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 together to perform multiple tests, one after the other as in this fragment
 of a calculator
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (op==
\begin_inset Quotes erd
\end_inset

+
\begin_inset Quotes erd
\end_inset

) {
\end_layout

\begin_layout Plain Layout

  r = a + b
\end_layout

\begin_layout Plain Layout

} else if (op==
\begin_inset Quotes erd
\end_inset

-
\begin_inset Quotes erd
\end_inset

) {
\end_layout

\begin_layout Plain Layout

  r = a - b
\end_layout

\begin_layout Plain Layout

} else if (op==
\begin_inset Quotes erd
\end_inset

*
\begin_inset Quotes erd
\end_inset

) {
\end_layout

\begin_layout Plain Layout

  r = a * b
\end_layout

\begin_layout Plain Layout

} else if (op==
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

) {
\end_layout

\begin_layout Plain Layout

  r = a / b
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  print 
\begin_inset Quotes eld
\end_inset

Unknown operation
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Note that only one code block will be executed in such an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if ...
 else
\end_layout

\end_inset

 
\emph on
tree
\emph default
.
\end_layout

\begin_layout Subsection
For loops
\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop is used to iterate over elements of a collection.
 You specify an iteration variable and the collection to iterate over enclosed
 in parentheses and using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 keyword; this is then followed by a statement to be repeatedly executed,
 the 
\emph on
loop body
\emph default
.
 At each iteration, the iteration variable takes on successive values from
 the collection.
 This example prints the numbers 1 to 10 using a Range
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (i in 1..10) print i
\end_layout

\end_inset

where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

 is the iteration variable and here the loop body is a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print
\end_layout

\end_inset

 statement.
 Any collection can be used, for example this List of functions
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (f in [sin, cos, tan]) print f(Pi/2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Loops may also use a code block for the body 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (r in collection) {
\end_layout

\begin_layout Plain Layout

  // Do some processing
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It's occasionally useful to access an integer index used to iterate over
 the collection, for example when working with two parallel collections.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (q, k in lst) {
\end_layout

\begin_layout Plain Layout

	p[k] = q
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
While loops
\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 loop tests whether a condition test is true; if it is it then executes
 the loop body and this process is repeated until the condition test fails.
 They're particularly useful where the loop is modifying something as it
 iterates.
 For example, this loop prints the contents of a list in reverse order,
 popping them off one by one
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = List(1..10)
\end_layout

\begin_layout Plain Layout

while (a.count()>0) print a.pop()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example reads the contents of a text file and prints it to the screen
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var f = File(
\begin_inset Quotes eld
\end_inset

file.txt
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

) // Open file to read
\end_layout

\begin_layout Plain Layout

while (!f.eof())  {
\end_layout

\begin_layout Plain Layout

  print f.readline()
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

f.close()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Very occasionally, it's useful to make an infinite loop and terminate it
 based on a condition test somewhere in the middle.
 To do so, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 keyword as will be discussed later in the chapter 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

while(true) {
\end_layout

\begin_layout Plain Layout

	// ..
\end_layout

\begin_layout Plain Layout

	if(somethingHappened()) break
\end_layout

\begin_layout Plain Layout

	// ..
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Do...while loops
\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

do...while
\end_layout

\end_inset

 loop is similar to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 loop, but the condition test is performed after the loop body has executed.
 Hence the loop body is always executed 
\emph on
at least once
\emph default
.
 This is a skeleton Read-Evaluate-Print loop (REPL) loop that gets input
 from the user, processes it and displays the result, repeating the process
 until the user types 
\begin_inset Quotes eld
\end_inset

quit
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

do {
\end_layout

\begin_layout Plain Layout

  var in = System.readline()
\end_layout

\begin_layout Plain Layout

  // process input
\end_layout

\begin_layout Plain Layout

} while(in!=
\begin_inset Quotes erd
\end_inset

quit
\begin_inset Quotes erd
\end_inset

) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
C-style for loops
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 also provides a traditional C-style for loop.
 These are far less commonly used relative to the more modern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for ...
 in
\end_layout

\end_inset

 syntax, but are occasionally useful.
 They have the following structure
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (initializer; test; increment) body
\end_layout

\end_inset

incorporating four elements: 
\end_layout

\begin_layout Itemize
an 
\series bold
initializer
\series default
 creates iteration variables and sets their initial variables.
\end_layout

\begin_layout Itemize
the 
\series bold
test
\series default
 condition is evaluated, and the loop terminates unless the condition is
 true or equivalent to true.
 
\end_layout

\begin_layout Itemize
the 
\series bold
increment
\series default
 is evaluated after each iteration, and is typically used to increment iteration
 variables.
\end_layout

\begin_layout Itemize
the 
\series bold
body
\series default
 is evaluated each iteration as for other loops.
\end_layout

\begin_layout Standard
Hence the C-style loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (var i=0; i<5; i+=1) print i 
\end_layout

\end_inset

is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for ...
 in
\end_layout

\end_inset

 loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (i in 0...5) print i
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Return, break, continue
\begin_inset CommandInset label
LatexCommand label
name "subsec:Return,-break,-continue"

\end_inset


\end_layout

\begin_layout Standard
There are three keywords that transfer control to a different point in the
 program.
 The most commonly used is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

, which ends execution of the current function, and returns to the calling
 code.
 You may optionally provide an expression after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

, which is the result of the function as returned to the caller.
 Because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 is best understood in the context of functions, we defer further discussion
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 to the next chapter.
 
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statement exits the control structure and transfers execution to the code
 immediately
\emph on
 after
\emph default
 the structure.
 It's usually used to terminate a loop early.
 In this skeleton example, the programmer wants to perform up to a specified
 maximum number of iterations for an algorithm, but to finish once the algorithm
 has converged on the result
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (iter in 1...Niter) {
\end_layout

\begin_layout Plain Layout

  if (hasConverged()) break
\end_layout

\begin_layout Plain Layout

  // Do some work
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Execution continues here
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the other hand, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 is used, exclusively in loops, to skip immediately to the next iteration.
 It's often useful when processing a collection of data that includes elements
 that should be ignored.
 In this example, the condition checks whether an element in the given collectio
n is callable, and if it isn't the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 statement causes the loop to go to the next element in the collection.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (f in collection) {
\end_layout

\begin_layout Plain Layout

  if (!iscallable()) continue
\end_layout

\begin_layout Plain Layout

  var a = f()
\end_layout

\begin_layout Plain Layout

  // process the result
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 should be used judiciously because they transfer control nonlocally to
 another point in the program and hence introduce the possibility of confusion.
 It's always possible to replace them using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

, but this too can lead to tangled code.
 The previous code could be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (f in collection) {
\end_layout

\begin_layout Plain Layout

  if (iscallable()) {
\end_layout

\begin_layout Plain Layout

    var a = f()
\end_layout

\begin_layout Plain Layout

    // process the result
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

but there's a tradeoffthe extra level of indentation could make the code
 depending on the complexity of the processing code.
 The programmer should always keep in mind the clarity of the code written,
 and use one construct or another depending on which is clearer.
 
\end_layout

\begin_layout Subsection
Try...catch
\end_layout

\begin_layout Standard
Morpho provides a type of statement, denoting using the keywords 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

, that enables programs to handle error conditions that may be generated
 at runtime.
 This mechanism could be used, for example, by a program to recover if a
 file isn't found, or a resource is unavailable.
 The construct will be discussed more fully in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Handling-errors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Chapter
Functions
\begin_inset CommandInset label
LatexCommand label
name "chap:Functions"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Functions
\emph default
 are packages of code that accomplish a specific task.
 Sometimes called 
\emph on
subroutines
\emph default
 or 
\emph on
procedures
\emph default
 in other languages, the intent is the same: to modularize code into simple,
 understandable and reusable components.
 They can also be used to model the mathematical notion of a function, a
 
\emph on
map
\emph default
 from parameter values onto results.
 
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 provides a number of useful functions as standard, e.g.
 trigonometric functions, which are 
\emph on
called
\emph default
 by providing appropriate parameter values or 
\emph on
arguments
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print cos(Pi/4)
\end_layout

\end_inset

When Morpho encounters a function call, control is transferred to the function
 with the parameters initialized to the value of the supplied 
\emph on
arguments
\emph default
.
 Once the function has accomplished its task, it 
\emph on
returns
\emph default
 a value that can be used by the code that called it.
 In our example, the value of 
\begin_inset Formula $\cos(\pi/4)=2^{-1/2}$
\end_inset

 is returned by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos
\end_layout

\end_inset

 function and then displayed by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print
\end_layout

\end_inset

 statement.
 
\end_layout

\begin_layout Standard
Function calls can occur anywhere where an expression is allowed, including
 as part of another expression or as an argument to another function call
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print apply(cos, Pi/3 + arctan(1,0))
\end_layout

\end_inset

If the function is called without being used, the return value is simply
 discarded
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cos(Pi/2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To define a function, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fn
\end_layout

\end_inset

 keyword.
 This must be followed by the 
\emph on
name
\emph default
 of the function, a list of parameters enclosed in parentheses and the 
\emph on
function body
\emph default
, which is specified as a code block.
 Here's a function that simply doubles its argument
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn twice(x) {
\end_layout

\begin_layout Plain Layout

  return 2*x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 keyword, introduced above in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Return,-break,-continue"
plural "false"
caps "false"
noprefix "false"

\end_inset

, is used to introduce a return statement that indicates where control should
 be returned to the calling code.
 The expression after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 becomes the return value of the function.
 A function can contain more than one 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn sign(x) {
\end_layout

\begin_layout Plain Layout

  if (x>0) {
\end_layout

\begin_layout Plain Layout

    return 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  } else if (x<0) {
\end_layout

\begin_layout Plain Layout

    return 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  } else return 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement is provided, the function returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

 by default.
\end_layout

\begin_layout Standard
Functions can have multiple parameters.
 Here's another example that calculates the norm of a two dimensional vector
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn norm(x, y) {
\end_layout

\begin_layout Plain Layout

 var n2 = x^2 + y^2
\end_layout

\begin_layout Plain Layout

 return sqrt(n2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

norm
\end_layout

\end_inset

 is called, the 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 values must be supplied 
\emph on
in order
\emph default
.
 These parameters are therefore referred to as 
\emph on
positional parameters.
 
\emph default
They take on their value from the order of the arguments supplied.
 The calling code must call the function with the correct number of positional
 parameters, otherwise an
\emph on
 
\emph default

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

InvldArgs
\end_layout

\end_inset

 error is thrown.
\end_layout

\begin_layout Section
Optional parameters
\end_layout

\begin_layout Standard
Functions can also be defined with 
\emph on
optional parameters
\emph default
, sometimes referred to as 
\emph on
keyword 
\emph default
or 
\emph on
named
\emph default
 parameters in other languages.
 Optional parameters are declared after positional parameters and must include
 a 
\emph on
default value
\emph default
.
 This rather contrived example raises its argument to a power that can be
 optionally changed.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn optpow(x, a=2) {
\end_layout

\begin_layout Plain Layout

  return x^a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

optpow
\end_layout

\end_inset

 is called with just one parameter
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print optpow(3) // Expect: 9
\end_layout

\end_inset

the default value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a=2
\end_layout

\end_inset

 is used.
 But 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

optpow
\end_layout

\end_inset

 can also be called specifying a different value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print optpow(3, a=3) // Expect: 27
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can define multiple optional parameters as in this template to find
 a root of a specified function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn findRoot(f, method=nil, initialValue=0, tolerance=1e-6) {
\end_layout

\begin_layout Plain Layout

  // ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The caller can specify any number, including none, of the optional parameters
 so any of the following are valid
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

findRoot(f)
\end_layout

\begin_layout Plain Layout

findRoot(f, tolerance=1e-8)
\end_layout

\begin_layout Plain Layout

findRoot(f, tolerance=1e-6, initialValue=1)
\end_layout

\end_inset

Notice that the caller can supply optional parameters in any order; they
 need not correspond to the order in which they're provided in the function
 definition.
 The 
\emph on
Morpho
\emph default
 runtime automatically handles the correct assignment.
 If positional parametes are defined, however, they must be provided.
 Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findRoot
\end_layout

\end_inset

 with no arguments would throw an
\emph on
 
\emph default

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

InvldArgs
\end_layout

\end_inset

 error.
 
\end_layout

\begin_layout Standard
There are some restrictions on the default value of optional arguments.
 Currently, they may be any of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

, a boolean value, an Integer or a Float.
 For other kinds of values, use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nil
\end_layout

\end_inset

 as the default value and check whether an optional argument was provided
 in the function.
 For FindRoot, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

method
\end_layout

\end_inset

 parameter probably refers to some object or class that provides a user
 selectable algorithm.
 If no value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

method
\end_layout

\end_inset

 is provided, the function should select a default algorithm like so
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn findRoot(f, method=nil, initialValue=0, tolerance=1e-6) {
\end_layout

\begin_layout Plain Layout

  var m = method
\end_layout

\begin_layout Plain Layout

  if (isnil(m)) m = DefaultMethod() 
\end_layout

\begin_layout Plain Layout

  // ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Optional arguments are best used for functions that perform a complex action
 with many independent user-selectable parts, particularly those that may
 only needed infrequently.
 They alleviate the user of having to remember the order parameters must
 be given, and allow customization.
\end_layout

\begin_layout Section
Variadic parameters
\end_layout

\begin_layout Standard
Occasionally it is useful for a function to accept a variable number of
 parameters.
 A variadic parameter is indicated using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset

 notation, as in this example that sums its arguments:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn sum(...x) {
\end_layout

\begin_layout Plain Layout

  var total = 0
\end_layout

\begin_layout Plain Layout

  for (e in x) total+=e
\end_layout

\begin_layout Plain Layout

  return total
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When called, the parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is initialized as a special container object containing the arguments provided.
 It's valid to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 with no arguments provided, in which case the container 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is empty.
 
\end_layout

\begin_layout Standard
You may only designate one variadic parameter per function.
 Hence this example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn broken(...x, ...y) { // Invalid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

throws a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneVarPr
\end_layout

\end_inset

 error when compiled.
\end_layout

\begin_layout Standard
It's possible to combine positional and variadic parameters, as in this
 example that computes the 
\begin_inset Formula $L_{n}$
\end_inset

 norm of its parameters (at least for 
\begin_inset Formula $n\ge2)$
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn nnorm(n, ...x) { 
\end_layout

\begin_layout Plain Layout

  var total = 0
\end_layout

\begin_layout Plain Layout

  for (e in x) total+=e^n
\end_layout

\begin_layout Plain Layout

  return total^(1/n)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When a function that accepts both positional and variadic parameters is
 called, the required number of argument values are assigned to positional
 parameters first, and then any remaining arguments are assigned to the
 variadic parameter.
 Hence, you must call a function with at least the number of positional
 parameters.
 Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nnorm
\end_layout

\end_inset

 with no parameters will throw a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

InvldArgs
\end_layout

\end_inset

 error.
 
\end_layout

\begin_layout Standard
It's also required that the variadic parameter, if any, comes after positional
 parameters.
 This example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn broken(...x, y, z) { // Invalid
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

would throw a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

VarPrLst
\end_layout

\end_inset

 error on compilation.
 
\end_layout

\begin_layout Standard
Optional parameters must be defined after any variadic parameter.
 We could redefine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nnorm
\end_layout

\end_inset

 to make it compute the 
\begin_inset Formula $L_{2}$
\end_inset

 norm by default like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn nnorm(...x, n=2) { 
\end_layout

\begin_layout Plain Layout

  var total = 0
\end_layout

\begin_layout Plain Layout

  for (e in x) total+=e^n
\end_layout

\begin_layout Plain Layout

  return total^(1/n)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multiple dispatch
\end_layout

\begin_layout Standard
While Morpho functions, by default, accept any value for each parameter,
 it's often the case that a function's behaviour depends on the type of
 one or more of its arguments.
 You can therefore define functions to restrict the type of arguments accepted,
 and you can even define multiple implementations of the same function that
 accept different types.
 The correct implementation is selected at runtimethis is known as 
\emph on
multiple dispatch
\emph default
depending on the actual types of the caller.
 It is sometimes clear to the compiler which implementation will be called,
 in which case the compiler will select this automatically.
 
\emph on
Morpho
\emph default
 implements multiple dispatch efficiently, and so the overhead of this relative
 to a regular function call is small.
 
\end_layout

\begin_layout Standard
Consider this skeleton intended to compute the gamma function, a mathematical
 special function that is related to factorials for integer values, and
 which is also defined for the complex plane:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn gamma(Int x) { 
\end_layout

\begin_layout Plain Layout

  if (x>0) return Inf
\end_layout

\begin_layout Plain Layout

  return factorial(x-1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fn gamma(Float x) {
\end_layout

\begin_layout Plain Layout

  // An implementation for Floating point numbers
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fn gamma(Complex x) {
\end_layout

\begin_layout Plain Layout

  // Another implementation
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

gamma
\end_layout

\end_inset

 is called, one of the three implementations is selected depending on whether
 the argument is an Integer, Float and Complex number.
 If no implementation is available, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MltplDsptchFld
\end_layout

\end_inset

 error is thrown.
 This could happen, for example, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

gamma
\end_layout

\end_inset

 is called with a List by mistake.
 Implementations need not have the same number of arguments.
 Here's a collection of implementations that return the number of arguments
 provided:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn c() { return 0 }
\end_layout

\begin_layout Plain Layout

fn c(x,y) { return 1 }
\end_layout

\begin_layout Plain Layout

fn c(x,y,z) { return 2 }
\end_layout

\begin_layout Plain Layout

fn c(x,y,z,w) { return 3 }
\end_layout

\end_inset

Multiple dispatch can occur on any combination of positional parameters
 and not all positional parameters need to be typed.
 The ordered collection of types accepted by the positional arguments of
 an implementation is known as its 
\emph on
signature
\emph default
.
 This enterprising collection joins Strings to Lists, producing a String.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn join(String x, List y) { return x + String(y) }
\end_layout

\begin_layout Plain Layout

fn join(String x, String y) { return x + y }
\end_layout

\begin_layout Plain Layout

fn join(List x, String y) { return String(x) + y }
\end_layout

\begin_layout Plain Layout

fn join(List x, List y) { return String(x) + String(y) }
\end_layout

\end_inset

It's an error to define two implementations with the same signature within
 the same scope.
\end_layout

\begin_layout Section
Documentation
\end_layout

\begin_layout Standard
We highly recommend documenting each function with a comment before (or
 close to) the function definition.
 The set of parameters is known as the 
\emph on
interface
\emph default
 of the function, and it's recommended to document the meaning and purpose
 of each parameter, as well as any restrictions, constraints or required
 units.
 There are many valid styles to accomplish this, but the importance of documenti
ng interfaces cannot be emphasized enough.
\end_layout

\begin_layout Chapter
Functions as data
\end_layout

\begin_layout Standard
Functions in 
\emph on
Morpho
\emph default
 are objects just like Lists, Strings, etc.
 Hence, they can be assigned to variables, and called at a later point
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var P = sin
\end_layout

\begin_layout Plain Layout

print P(Pi/10)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions can also be stored in collections.
 This example computes the value of several trigonometric functions, which
 are stored in a list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var lst = [sin, cos, tan]
\end_layout

\begin_layout Plain Layout

for (f in lst) print f(Pi/3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, functions can be passed as arguments to other functions.
 For example, here's a function that applies a given function twice to its
 second argument
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn calltwice(f, x) { 
\end_layout

\begin_layout Plain Layout

  return f(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

You can then use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

calltwice
\end_layout

\end_inset

 with any function, as in this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn sqr(x) {
\end_layout

\begin_layout Plain Layout

  return x^2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print calltwice(sqr, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Anonymous functions
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 provides an abbreviated syntax for functions that can be used in assignments
 or as parameters.
 There's no need to give the function a namesuch functions are hence called
 
\emph on
anonymous
\emph default
and you may, optionally, provide a single statement as the body in place
 of the usual code block.
 The value of the body statement is returned from the function as if a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 was in front of it.
 Hence
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var sq = fn (a) a^2
\end_layout

\end_inset

is equivalent to the named function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn sqr(a) {
\end_layout

\begin_layout Plain Layout

  return a^2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The anonymous function syntax is particularly useful for supplying to other
 functions, because quite often such functions end up being quite short.
 The List class, for example, provides a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sort
\end_layout

\end_inset

 method that can be used to sort the contents.
 You can optionally provide a sort function that compares two elements of
 the list 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

; this function should return a negative value if 
\begin_inset Formula $a<b$
\end_inset

, a positive value if 
\begin_inset Formula $a>b$
\end_inset

 and 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are equal.
 This example sorts the list in reverse order
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var lst = [5,2,8,6,5,0,1,3,4]
\end_layout

\begin_layout Plain Layout

lst.sort(fn (a,b) b-a)
\end_layout

\begin_layout Plain Layout

print lst
\end_layout

\end_inset

In some languages, anonymous functions are referred to as 
\emph on
lambda
\emph default
 functions, referring to the pioneering work of Alonzo Church on the theory
 of computation.
 
\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Standard
Functions obey scope so functions can be defined locally within a code block
 as in this example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  fn f(x) { return x^2 }
\end_layout

\begin_layout Plain Layout

  print f(2) // prints 4
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print f(2) // Raises an error
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 remains available for the rest of the code block, but is not visible outside
 of it.
 Hence, while the first call works, the second throws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SymblUndf
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is no longer visible.
 
\end_layout

\begin_layout Section
Closures
\end_layout

\begin_layout Standard
Functions can be 
\emph on
returned
\emph default
 from other functions; such functions are known as 
\emph on
closures
\emph default
 for reasons that will become apparent shortly.
 Here's an example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn inc(a) {
\end_layout

\begin_layout Plain Layout

  fn f(x) { return x + a }
\end_layout

\begin_layout Plain Layout

  return f 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var add = inc(5)
\end_layout

\begin_layout Plain Layout

print add(10) // prints 15
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inc
\end_layout

\end_inset

 manufactures a closure that adds a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 to its argument.
 This can be a bit complicated to follow, so let's trace out the sequence
 of events: 
\end_layout

\begin_layout Enumerate
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inc
\end_layout

\end_inset

 is called with the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5
\end_layout

\end_inset

.
 During the call, the parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 takes on this value inside the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inc
\end_layout

\end_inset

 function.
 
\end_layout

\begin_layout Enumerate
A closure using the local function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is created within 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inc
\end_layout

\end_inset

 using the provided value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 (i.e.
 5).
 
\end_layout

\begin_layout Enumerate
The closure is returned to the calling code.
 The value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 remains available to the closure.
\end_layout

\begin_layout Enumerate
The user calls the closure with the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

; the closure adds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5
\end_layout

\end_inset

 to this and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

15
\end_layout

\end_inset

 which is displayed.
\end_layout

\begin_layout Standard
Closures are so-named because they 
\emph on
enclose
\emph default
 the environment in which they're created.
 In this example, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 is encapsulated together with the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, forming the closure.
 The quantity 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 as is sometimes called an 
\emph on
upvalue
\emph default
, because it's not local to the function definition; 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 is said to be 
\emph on
captured
\emph default
 by the closure.
 
\end_layout

\begin_layout Standard
Upvalues can be written to as well as read from.
 This closure reports how many times it has been called
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn counter(val) {
\end_layout

\begin_layout Plain Layout

  fn f() { val+=1; return val }
\end_layout

\begin_layout Plain Layout

  return f 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var c = counter(0)
\end_layout

\begin_layout Plain Layout

print c() // prints 1
\end_layout

\begin_layout Plain Layout

print c() // prints 2
\end_layout

\begin_layout Plain Layout

print c() // prints 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Closures can be called anywhere regular functions can.
 An important use of closures is to create functions that obey a defined
 interface, i.e.
 they have the same signature, but have access to additional parameters.
 This example creates a function that describes the electric scalar potential
 due to a point charge with given charge and position
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fn scalarPotential(q, x0, y0) {
\end_layout

\begin_layout Plain Layout

  fn phi(x,y) {
\end_layout

\begin_layout Plain Layout

    return q/sqrt((x-x0)^2 + (y-y0)^2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return phi
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var p1 = scalarPotential(1, -1, 0)
\end_layout

\begin_layout Plain Layout

var p2 = scalarPotential(-1, 1, 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print p1(0,1) + p2(0,1)
\end_layout

\end_inset

The closures created can then be called with position of interest, returning
 the appropriate value.
 This could be useful in a larger code, where potential functions for many
 different types of entity are to be created, but each type requires very
 different data to specify them.
 Nonetheless, because all such potential functions obey the same interface,
 they can be used interchangably.
 
\end_layout

\begin_layout Chapter
Classes and Objects
\begin_inset CommandInset label
LatexCommand label
name "chap:Classes-and-Objects"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
, in contrast to many dynamic languages, is strongly oriented towards object
 oriented programming (OOP).
 The central idea behind OOP is to encapsulate related data or 
\emph on
properties
\emph default
 into packages called 
\emph on
objects
\emph default
 that also supply a collection of actions or 
\emph on
methods
\emph default
 that can be performed on them.
 Methods are much like functionsthey have parameters and return valuesexcept
 they are always called with reference to a particular object.
 A method call is specified in 
\emph on
Morpho
\emph default
 using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 operator:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var a = [1,2,3]
\end_layout

\begin_layout Plain Layout

print a.count()
\end_layout

\end_inset

Here, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 method returns the number of entries in a List.
 Many 
\emph on
Morpho
\emph default
 objects provide the same method.
 The left hand operand of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 operator is called the 
\emph on
receiver
\emph default
 of the call and the label 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 is called the 
\emph on
selector
\emph default
.
 Like functions, method calls can have parameters and return values.
 
\end_layout

\begin_layout Standard
To define new object types, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 keyword.
 A 
\emph on
class
\emph default
 provides the definition of an object type in that it comprises the methods
 available to the object; objects themselves are 
\emph on
instances
\emph default
 of a particular class and are made using a 
\emph on
constructor
\emph default
.
 Let's create a simple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 class with two methods, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

greet
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Pet {
\end_layout

\begin_layout Plain Layout

  init(name) {
\end_layout

\begin_layout Plain Layout

    self.name = name
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  greet() {
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset

You greet ${self.name}!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 
\emph on
instance
\emph default
, we write a constructor, which uses the same syntax as a function call.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var whiskers = Pet(
\begin_inset Quotes eld
\end_inset

Whiskers
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

Since 
\emph on
Morpho
\emph default
 classes generally begin with capital lettersalthough the language doesn't
 enforce this explicitlyyou can usually spot constructors easily in code.
 
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 method that we defined in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 is special: if provided, it's called 
\emph on
immediately
\emph default
 after the object is created, and before the constructed object is returned
 to the user, and is intended to prepare the object for use.
 Here, we store the provided name in the object's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 property.
 Note that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 method must not return a value; if you try to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 in its definition, the compiler will throw an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

InitRtn
\end_layout

\end_inset

 error.
 It's also a good idea to avoid complex code in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 method; if your object requires significant setup, or is complicated to
 create, consider using the Builder pattern described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Builder"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Inheritance
\end_layout

\begin_layout Standard
A key goal of object oriented programming is 
\emph on
reuse
\emph default
 of code.
 In class-based languages like Morpho, you can create a new class that reuses
 the methods provided by a previously defined class using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is
\end_layout

\end_inset

 keyword; the prior class is called the 
\emph on
parent
\emph default
 of the new class, which becomes its 
\emph on
child
\emph default
.
 Here, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cat
\end_layout

\end_inset

 class inherits from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Cat is Pet {
\end_layout

\begin_layout Plain Layout

  hiss() {
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset

${self.name} hisses!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Any methods defined in the parent class are copied into the child class,
 so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cat
\end_layout

\end_inset

 acquires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

, but also defines a new method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hiss
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Multiple inheritance
\end_layout

\begin_layout Standard
A programmer may wish to make a class by combining unrelated functionality
 from different classes, a design strategy known as 
\emph on
composition
\emph default
.
 If classes only inherit from one parenta paradigm called
\emph on
 single inheritance
\emph default
this is challenging and requires special techniques to overcome the limitation.
 To support composition, 
\emph on
Morpho
\emph default
 classes can inherit from multiple parents.
 Let's create a class, Walker, that describes something that can 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

walk
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Walker  {
\end_layout

\begin_layout Plain Layout

  walk() {
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset

${self.name} walks!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog
\end_layout

\end_inset

 class by composing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Walker
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Dog is Pet with Walker {
\end_layout

\begin_layout Plain Layout

  bark() {
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset

${self.name} barks!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog
\end_layout

\end_inset

 class inherits 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

walk
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Walker
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
If two parents (or their parents) provide the same method, there is a special
 mechanism called 
\emph on
method resolution
\emph default
 that determines which implementation is actually inherited by a class;
 we'll describe it in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Method-resolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
 
\end_layout

\begin_layout Section
Multiple dispatch
\end_layout

\begin_layout Standard
Like functions, methods utilize multiple dispatch: You may define multiple
 implementations that accept different types of argument.
 In languages like C++, similar functionality is provided by 
\emph on
overloading
\emph default
, multiple dispatch generalizes this idea.
 
\end_layout

\begin_layout Section
Method resolution
\begin_inset CommandInset label
LatexCommand label
name "sec:Method-resolution"

\end_inset


\end_layout

\begin_layout Standard
If more than one parent or ancestor classes provide methods with the same
 name, the following rules apply:
\end_layout

\begin_layout Enumerate

\series bold
Priority.
 
\series default
Method implementations have priority given by a 
\emph on
linearization
\emph default
 of the class structure; i.e.
 the compiler computes a ordering of the parent classes consistent with
 ordering relationships expressed in the class definitions.
 For each class definition, priority of the parents is given left to right,
 so the direct parent given after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is
\end_layout

\end_inset

 has priority over those parents specified by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

with
\end_layout

\end_inset

, which then take priority in the order given.
 The algorithm used is called C3 linearization
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Kim Barrett, Bob Cassels, Paul Haahr, David A.
 Moon, Keith Playford, P.
 Tucker Withington (1996-06-28).
 
\begin_inset Quotes eld
\end_inset

A Monotonic Superclass Linearization for Dylan
\begin_inset Quotes erd
\end_inset

.
 OOPSLA '96 Conference Proceedings.
 ACM Press.
 pp.
 6982.
 CiteSeerX 10.1.1.19.3910.
 doi:10.1145/236337.236343.
 ISBN 0-89791-788-X.
\end_layout

\end_inset

, and for our simple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog
\end_layout

\end_inset

 example yields the ordering 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog, Pet, Walker
\end_layout

\end_inset

: Methods in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog
\end_layout

\end_inset

 have priority over those in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

, which have priority over those in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Walker
\end_layout

\end_inset

.
 You can obtain the linearization computed by the compiler for a class by
 calling the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

linearization
\end_layout

\end_inset

 method on the class, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print Dog.linearization()
\end_layout

\end_inset

 (an example of 
\emph on
reflection
\emph default
 described in the next section).
 Not all possible class structures admit a C3 linearization; an error is
 raised at compile time where a linearization cannot be computed.
 
\end_layout

\begin_layout Enumerate

\series bold
Similarity.
 
\series default
Methods with the same name and the same 
\emph on
signature
\emph default
 are considered to be 
\emph on
similar
\emph default
.
 When assembling a new class's methods from its definition and parents,
 the implementation whose class that comes first in the priority list is
 used.
 Hence, an implementation in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dog
\end_layout

\end_inset

 would replace one in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pet
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Walker
\end_layout

\end_inset

.
 An error is raised if a class definition provides two similar implementations.
 
\end_layout

\begin_layout Standard
While these rules may seem complicated, in most cases they correspond to
 what the programmer expects.
 Pathological examples certainly exist, and the programmer is advised to
 be wary of deep inheritance structures.
 Favor composition over inheritance is a commonly advised design principle.
 
\end_layout

\begin_layout Section
Reflection
\begin_inset CommandInset label
LatexCommand label
name "sec:Reflection"

\end_inset


\end_layout

\begin_layout Standard
Like many dynamic languages, 
\emph on
Morpho
\emph default
 provides facilities for code to discover an object's properties and methods
 at runtime.
 
\end_layout

\begin_layout Chapter
Errors
\begin_inset CommandInset label
LatexCommand label
name "chap:Handling-errors"

\end_inset


\end_layout

\begin_layout Standard
Computer programs written in any language may encounter unexpected or challengin
g situations.
 The user might request that the program opens a file, for example, but
 the file doesn't exist.
 An algorithm might call for the solution of a linear system, but the matrix
 turns out to be poorly conditioned.
 Both these examples are forseeable by the programmer at the time of writing,
 so an appropriate course of action can be taken by the program.
 Perhaps the user should be informed that the file didn't exist or that
 the algorithm didn't succeed, or perhaps an alternative algorithm is available.
 
\end_layout

\begin_layout Standard
There are three kinds of error in 
\emph on
Morpho
\emph default
:
\end_layout

\begin_layout Itemize

\series bold
Compilation errors
\series default
 are thrown when the provided code is incorrect.
 If the 
\emph on
Morpho
\emph default
 compiler can't find a symbol, it throws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SymblUndf
\end_layout

\end_inset

, for example.
 Compilation errors prevent the code from running at all; they must be fixed
 by the programmer rather than handled by the code.
\end_layout

\begin_layout Itemize

\series bold
Runtime errors
\series default
 are thrown during execution of the program and indicate that execution
 cannot proceed further.
 Execution therefore halts, and the runtime environment displays a message
 describing the error and where it occurred.
 
\end_layout

\begin_layout Itemize

\series bold
Runtime warnings.

\series default
 Occasionally, a situation occurs that isn't strictly an error, but something
 is unusual that the user should be told about.
 An algorithm that solves a problem may wish to report that the quality
 of the solution is poorer than expected.
 Or perhaps the user used deprecated functionality, and the program wishes
 to suggest an alternative.
 Warnings do not interrupt execution; they simply display a highlighted
 message to the user.
 
\end_layout

\begin_layout Standard
All errors in Morpho have two components: a short 
\emph on
tag 
\emph default
that identifies the error, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SymblUndf
\end_layout

\end_inset

, and a longer 
\emph on
description
\emph default
.
 This structure is intended to support internationalization, because locale-appr
opriate descriptions could be loaded, and also support a need for customized
 error messages that can include useful information.
 
\end_layout

\begin_layout Standard
Errors are instances of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

 class, which can be used to create new errors.
 You supply the tag and a default error message in the constructor
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var myErr = Error(
\begin_inset Quotes eld
\end_inset

MyTag
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Default error message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

Once the error is created, call the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 method to throw the error
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

myErr.throw()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any error can also be used as a 
\emph on
warning
\emph default
 as described above by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warning
\end_layout

\end_inset

 method 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

myErr.warning()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warning
\end_layout

\end_inset

 with a custom message provided as a String, which is useful if you want
 to provide more information to the user about what happened
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

myErr.throw(
\begin_inset Quotes eld
\end_inset

File ${foo} was missing.
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Handling errors
\end_layout

\begin_layout Standard
While not necessarily expected, some errors are at least forseeable.
 A well written program should handle such errors gracefully, and provide
 an alternate course of action if possible.
 If the user requests a file that isn't available, the program can notify
 them of this fact and request a different file, for example.
 
\end_layout

\begin_layout Standard
Morpho provides a control structure to handle errors using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 keywords
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

  f = File(fname, 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

} catch {
\end_layout

\begin_layout Plain Layout

  
\begin_inset Quotes eld
\end_inset

FlOpnFld
\begin_inset Quotes erd
\end_inset

: 
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset

File ${fname} not found
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 statement describes code to be executed that is anticipated may throw an
 error.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 statement defines an 
\emph on
error handler
\emph default
, a collection of errors that can be handled and code to handle them.
 You provide the appropriate tag for each error to handle, here just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FlOpnFld
\end_layout

\end_inset

, and a corresponding statement to execute if and only if the error is generated.
 You may use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 keyword within a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 statement, which allows you to escape from the error handler entirely.
\end_layout

\begin_layout Standard
If the code in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 block generates 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FlOpnFld
\end_layout

\end_inset

, control is transferred to the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 statement, which in this case prints an error.
 If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 statement doesn't thrown any errors, code in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 statement isn't executed.
 
\end_layout

\begin_layout Standard
What if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 block throws an error that isn't handled by the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 statement? Error handlers work on a stack, so every time 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 is executed, the 
\emph on
Morpho
\emph default
 runtime adds the corresponding handler to the stack; once the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try ...
 catch
\end_layout

\end_inset

 statement is finished executing the error handler is removed from the stack.
 More than one error handler can be active if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try ...
 catch
\end_layout

\end_inset

 statements are nested, for example, or if a function called within a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 statement provides its own error handler.
 In any case, when an error is thrown, the 
\emph on
Morpho
\emph default
 runtime looks at the most recent error handler, i.e.
 the handler from the most recently executed 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 statement.
 If the error can be handled by the handler, then control is transferred
 to it; if not, the runtime walks back along the stack of error handlers
 until one is found that can handle the error.
 If 
\emph on
no
\emph default
 suitable handler is found, the error is reported the user and interrupts
 execution as in the absence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Because error handlers can transfer control very non-locallyjumping outside
 of multiple nested function or method calls in extreme casesthey should
 be used with care.
 It's a good idea to document errors each function might throw, and to consider
 carefully possible errors that might need to be handled by your code.
 
\end_layout

\begin_layout Standard
Note that 
\emph on
Morpho
\emph default
 does 
\series bold
not
\series default
 provide a 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 error handler, i.e.
 a section of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 block that catches all errors.
 This is because the intent of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try ...
 catch
\end_layout

\end_inset

 is to handle 
\emph on
forseen
\emph default
 errors only.
 
\end_layout

\begin_layout Chapter
Libraries
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 is a modular environment.
 A number of standard libraries
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The 
\emph on
Morpho
\emph default
 runtime distinguishes between 
\emph on
modules
\emph default
, which are written in Morpho, and 
\emph on
extensions
\emph default
, which are written in C or another compiled language.
 Both are used in the same way and the distinction is transparent to programmers
 other than those seeking to implement their own module or extension.
 
\end_layout

\end_inset

 are provided, and you can easily write and distribute your own.
 To use a library, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 keyword
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import color
\end_layout

\end_inset

When compiling this code, the 
\emph on
Morpho
\emph default
 compiler looks for a library called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color
\end_layout

\end_inset

really a file names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color.morpho
\end_layout

\end_inset

in a number of standard locations that depend on the platform and how 
\emph on
Morpho
\emph default
 was installed; the collection of seach locations is called the 
\emph on
environment
\emph default
.
 
\emph on
Morpho
\emph default
 
\emph on
packages
\emph default
, bundles of code, help files, documentation etc.
 can be added to the environment by the user and provide a structured mechanism
 to extend its capabilities.
 
\end_layout

\begin_layout Standard
Once a library has been imported, anything it defines becomes available
 to the user: classes, functions and even global variables.
 These collectively are referred to as the 
\emph on
symbols
\emph default
 defined by the library.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color
\end_layout

\end_inset

 module provides a few named colors, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Color
\end_layout

\end_inset

 class, as well as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ColorMap
\end_layout

\end_inset

 objects that map a scalar parameter to a range of colors (useful for plotting).
 
\end_layout

\begin_layout Standard
You can also load a 
\emph on
Morpho
\emph default
 file using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import 
\begin_inset Quotes eld
\end_inset

mylibrary.morpho
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

In this case, the compiler looks for the file 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

mylibrary.morpho
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 in the same folder as your code; it doesn't search the environment for
 the file.
 You can load files in subfolders using UNIX path syntax
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import 
\begin_inset Quotes eld
\end_inset

folder/mylibrary.morpho
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

If necessary, the 
\emph on
Morpho
\emph default
 compiler will translate the UNIX path into a platform specific descriptor.
 
\end_layout

\begin_layout Standard
Unlike in some languages, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 can 
\emph on
only
\emph default
 be used in the global scope, but it can be used at any suitable point in
 the program.
 You may also import more than one library per line
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import color, meshtools
\end_layout

\end_inset

and these are then imported in the order specified.
 
\end_layout

\begin_layout Section
Importing selected symbols
\end_layout

\begin_layout Standard
Sometimes, the programmer only wants to use a subset of the features of
 a library.
 To do this, use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 keyword together with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 to select which symbols to import.
 This statement imports a special color-accessible 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ColorMap
\end_layout

\end_inset

 from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color
\end_layout

\end_inset

 module
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import color for ViridisMap
\end_layout

\end_inset

Note that 
\emph on
no other 
\emph default
symbols from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color
\end_layout

\end_inset

 are imported, not even 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ColorMap
\end_layout

\end_inset

 from which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ViridisMap
\end_layout

\end_inset

 inherits.
 
\end_layout

\begin_layout Standard
Judicious use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import ...
 for
\end_layout

\end_inset

 improves the robustness of code.
 As libraries are updated, new symbols may be added that could conflict
 with a symbol in the code using the libary.
 By making only the components needed accessible, the possibility of conflicts
 is reduced.
\end_layout

\begin_layout Section
Namespaces
\end_layout

\begin_layout Standard
Avoidance of conflicts between libraries motivates a more general construct
 called a 
\emph on
namespace
\emph default
.
 These are containers for symbols defined at compile time; any library can
 be imported into a designated namespace using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 keyword, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import color as col
\end_layout

\end_inset

where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

col
\end_layout

\end_inset

 is the name of the namespace created to contain the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

color
\end_layout

\end_inset

 libraries definitions.
 Once a namespace has been defined, its contents can be accessed using the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 operator, similar to a property lookup:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var c = col.Red()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A namespace lookup can be used 
\emph on
anywhere
\emph default
 where a regular identifier could be used, e.g.
 in constructors, function definitions and function calls, type specifiers,
 etc.
 The compiler attempts to locate the given the symbol in the namespace,
 and throws an error 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SymblUndfNmSpc
\end_layout

\end_inset

 if it cannot be found.
\end_layout

\begin_layout Section
Multiple includes
\end_layout

\begin_layout Standard

\emph on
Morpho
\emph default
 will 
\emph on
never
\emph default
 load the same library twice, even if it is imported more than once, and
 even if it is imported using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 as described below.
 Different 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 statements can even use the library in different waysMorpho will automatically
 ensure the correct symbols are available.
 
\end_layout

\begin_layout Chapter
Design Patterns
\end_layout

\begin_layout Standard
Object oriented code often utilizes 
\emph on
design patterns
\emph default
, code templates that show how to achieve a desired effect.
 The term is inspired by 
\emph on
pattern books
\emph default
, volumes that contain plans or diagrams to aid in making something.
 Such books are still used nowadays to sew or weave material, and in the
 19th century were a common way of building a house without the expense
 of hiring an architect.
 A very famous computer science book, 
\emph on

\begin_inset Quotes eld
\end_inset

Design Patterns: Elements of Reusable Object-Oriented Software
\begin_inset Quotes erd
\end_inset


\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Gamma,Erich,etal.
\emph on

\begin_inset Quotes eld
\end_inset

Design Patterns: Elements of Reusable Object-Oriented Software
\begin_inset Quotes erd
\end_inset


\emph default
.Germany,Addison-Wesley,1995.
\end_layout

\end_inset

 popularized the idea and provided a number of design patterns in widespread
 use.
 In this chapter, we show how to implement a selection of these patterns
 that we have found particularly useful in writing 
\emph on
Morpho
\emph default
 code.
 Certain 
\emph on
Morpho
\emph default
 libraries use these patterns, and knowledge of the terminology can help
 the reader understand their design.
 In some cases, the 
\emph on
Morpho
\emph default
 implementation differs from the original pattern because of the language's
 features.
 Also noteworthy is the idea of an
\emph on
 anti-pattern
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Originally coined in Koenig, Andrew (MarchApril 1995).
 "Patterns and Antipatterns".
 Journal of Object-Oriented Programming.
 8 (1): 4648; there have been many books on the subject of anti-patterns
 in software design and project management.
\end_layout

\end_inset

, a design approach that may be obvious, but contains undesirable features
 and is to be avoided.
 We do not dwell on anti-patterns herethey are to be avoided after all!but
 a good programmer should read one of the many excellent texts on the subject.
 
\end_layout

\begin_layout Section
Builder
\begin_inset CommandInset label
LatexCommand label
name "sec:Builder"

\end_inset


\end_layout

\begin_layout Standard
The Builder pattern facilitates creation of objects that are complicated
 or expensive to creategeometric data structures such as Meshes are a good
 exampleor must be constructed in multiple stages.
 They accomplish this by separating initialization code into a separate
 class.
 Another use case is where the type of object created may depend on parameters
 the user supplies: a MatrixBuilder, for example, might create a regular
 Matrix or a ComplexMatrix depending on whether the contents are real or
 complex numbers.
 A Builder is initialized with parameters describing the object to be created,
 and provides one method:
\end_layout

\begin_layout Itemize

\series bold
build()
\series default
 Constructs and returns the requested object.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Builder {
\end_layout

\begin_layout Plain Layout

  init(parameter) {
\end_layout

\begin_layout Plain Layout

    self.parameter = parameter
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  build() {
\end_layout

\begin_layout Plain Layout

    var obj = Object() // Make object
\end_layout

\begin_layout Plain Layout

    // Initialize it
\end_layout

\begin_layout Plain Layout

    return obj
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If the object requires multiple steps to create it, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

build
\end_layout

\end_inset

 can be replaced by appropriate build stages.
 
\end_layout

\begin_layout Section
Visitor
\end_layout

\begin_layout Standard
The Visitor pattern accomplishes the task of processing a collection of
 heterogeneous objects.
 A Visitor object is constructed with the collection to process, and provides
 two methods:
\end_layout

\begin_layout Itemize

\series bold
visit()
\series default
 Processes a single element of the collection.
 Multiple implementations of this method are provided that process different
 kinds of object.
 
\end_layout

\begin_layout Itemize

\series bold
traverse()
\series default
 Loops over the collection, calling the 
\series bold
visit()
\series default
 method for each object in turn.
 The correct implementation is selected automatically by multiple dispatch.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Visitor {
\end_layout

\begin_layout Plain Layout

  init(collection) {
\end_layout

\begin_layout Plain Layout

    self.collection = collection
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(Type1 a) {
\end_layout

\begin_layout Plain Layout

    // Do something
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(Type2 b) {
\end_layout

\begin_layout Plain Layout

    // Do something 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(x) { 
\end_layout

\begin_layout Plain Layout

    // Default 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  traverse() {
\end_layout

\begin_layout Plain Layout

    for (p in self.collection.contents()) self.visit(p)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Example: SVG export for vector graphics
\end_layout

\begin_layout Standard
To illustrate use of the Visitor class, let's create an example of a collection
 that might benefit from it.
 A 2D vector graphics image comprises various graphics primitives, e.g.
 lines, circles, polygons, etc.
 Here's a simple implementation that incorporates a couple of basic primitives:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class GraphicsPrimitive {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Circle is GraphicsPrimitive {
\end_layout

\begin_layout Plain Layout

  init(x,y,r) { self.x = x; self.y = y; self.r = r }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Line is GraphicsPrimitive {
\end_layout

\begin_layout Plain Layout

  init(x1,y1,x2,y2) { self.start = [x1,y1]; self.end = [x2,y2] }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Graphics2D {
\end_layout

\begin_layout Plain Layout

  init() { self.contents = [] }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  append(GraphicsPrimitive x) { // Adds a primitive to the collection
\end_layout

\begin_layout Plain Layout

    self.contents.append(x)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  contents() { return self.contents }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The user can then build up an image
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A good potential use of a Builder pattern!
\end_layout

\end_inset

 by creating a blank Graphics2D object and adding elements one by one.
 Here, we create a disk enclosed by a square:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var g = Graphics2D() 
\end_layout

\begin_layout Plain Layout

g.append(Circle(50,50,50))
\end_layout

\begin_layout Plain Layout

g.append(Line(0,0,0,100))     // Left
\end_layout

\begin_layout Plain Layout

g.append(Line(100,0,100,100)) // Right
\end_layout

\begin_layout Plain Layout

g.append(Line(0,0,100,0))     // Top
\end_layout

\begin_layout Plain Layout

g.append(Line(0,100,100,100)) // Bottom
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now imagine that we would like to export our Graphics2D object to a file,
 e.g.
 SVG, PDF, postscript, etc.
 The exporter class must traverse the contents of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Graphics2D
\end_layout

\end_inset

 object one by one and build up the output.
 Here's an example of a working SVG Exporter that accomplishes this using
 the Visitor pattern:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SVGExporter {
\end_layout

\begin_layout Plain Layout

  init(Graphics2D graphic) {
\end_layout

\begin_layout Plain Layout

    self.graphic = graphic
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(Circle c, f) {
\end_layout

\begin_layout Plain Layout

    f.write("<circle cx=
\backslash
"${c.x}
\backslash
" cy=
\backslash
"${c.y}
\backslash
" r=
\backslash
"${c.r}
\backslash
"/>") 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(Line l, f) {
\end_layout

\begin_layout Plain Layout

    f.write("<line x1=
\backslash
"${l.start[0]}
\backslash
" y1=
\backslash
"${l.start[1]}
\backslash
" x2=
\backslash
"${l.end[0]}
\backslash
" y2=
\backslash
"${l.end[1]}
\backslash
" stroke=
\backslash
"black
\backslash
"/>")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  visit(x, f) { } // Do nothing for unrecognized primitives
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  export(file) {
\end_layout

\begin_layout Plain Layout

    var f = File(file, "w")
\end_layout

\begin_layout Plain Layout

    f.write("<svg xmlns=
\backslash
"http://www.w3.org/2000/svg
\backslash
">")
\end_layout

\begin_layout Plain Layout

    for (p in self.graphic.contents()) self.visit(p, f)
\end_layout

\begin_layout Plain Layout

    f.write("</svg>")
\end_layout

\begin_layout Plain Layout

    f.close() 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To use the exporter, the user first creates an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SVGExporter
\end_layout

\end_inset

, passing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Graphics2D
\end_layout

\end_inset

 object to the constructor, and then calls the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

export
\end_layout

\end_inset

 method with a desired filename:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var svg = SVGExporter(g)
\end_layout

\begin_layout Plain Layout

svg.export("pic.svg")
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

export
\end_layout

\end_inset

 method creates the requested file, generates header information, and then
 loops over the content of the Graphics2D object, calling the visit method
 for each object.
 
\end_layout

\begin_layout Subsection
Advantages
\end_layout

\begin_layout Standard
The Visitor pattern enforces modularity by separating representation from
 processing of data.
 Since Graphics2D is intended to represent a vector image abstractly it
 shouldn't also provide the unrelated functionality of export facilities
 to particular filetypes.
 This separation makes it much easier to extend the program.
 A new graphics primitive could be defined without changing Graphics2D;
 only the SVGExporter would need to be modified, by adding an additional
 implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visit
\end_layout

\end_inset

.
 Similarly, support for additional graphics formats could be achieved without
 modifying the existing code above 
\emph on
at all.

\emph default
 All that needs to be done is to create a new class analogous to SVGExporter
 for the desired filetype.
 
\end_layout

\begin_layout Subsection
Comparison with other languages
\end_layout

\begin_layout Standard
Readers familiar with OOP design patterns may notice that the Visitor pattern
 described here is slightly different from the traditional implementation.
 In languages that lack multiple dispatch, the Visitor's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

export
\end_layout

\end_inset

 method first calls a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accept
\end_layout

\end_inset

 on each object in the collection, rather than calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visit
\end_layout

\end_inset

 on the Visitor itself:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

export(file) {
\end_layout

\begin_layout Plain Layout

  // Create file and write header
\end_layout

\begin_layout Plain Layout

  for (p in self.graphic.contents()) p.accept(self, f)
\end_layout

\begin_layout Plain Layout

  // Write footer and close file
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each Graphics primitive must provide an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accept
\end_layout

\end_inset

 method that in turn calls an appropriate method on the Visitor.
 For the Circle primitive, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accept
\end_layout

\end_inset

 might call a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visitCircle
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

accept(visitor, f) {
\end_layout

\begin_layout Plain Layout

  visitor.visitCircle(self, f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The Visitor must therefore provide a different method for each object type.
 Here's the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visitCircle
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

visitCircle(c, f) {
\end_layout

\begin_layout Plain Layout

  file.write("<circle cx=
\backslash
"${c.x}
\backslash
" cy=
\backslash
"${c.y}
\backslash
" r=
\backslash
"${c.r}
\backslash
"/>") 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The procedure described, where the Visitor calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accept
\end_layout

\end_inset

 on the object being processed that then dispatches the call to the correct
 method on the Visitor, is called 
\emph on
double dispatch
\emph default
.
 It's more convoluted and less efficient, requiring two method calls per
 processed object, than the multiple dispatch implementation.
 It's also less compact and less modular: with double dispatch, each primitive
 must provide an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accept
\end_layout

\end_inset

 method which is unnecessary in the multiple dispatch version.
 Indeed, all the functionality of the Visitor with multiple dispatch is
 contained within the Visitor, which could be highly advantageous if a collectio
n is from a library designed without the Visitor pattern in mind and where
 the code can't easily be modified.
 
\end_layout

\begin_layout Standard
Another advantage of the multiple dispatch is that a fallback 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visit
\end_layout

\end_inset

 method for unrecognized object types is trivially implemented.
 In other languages, adding a new primitive requires immediately modifying
 
\emph on
all
\emph default
 Visitor objects to avoid potentially raising an ObjLcksPrp error; in the
 multiple dispatch implementation, unknown primitives are simply routed
 to the fallback 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

visit
\end_layout

\end_inset

 method and ignored.
 
\end_layout

\end_body
\end_document
